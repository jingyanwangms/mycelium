/*globals define, WebGMEGlobal*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Mon Jul 22 2019 15:40:44 GMT-0700 (PDT).
 */

define([
    'panels/EasyDAG/EasyDAGControl',
], function (
    EasyDAGControl
) {

    'use strict';

    function SemanticGraphControl(options) {

        this._logger = options.logger.fork('Control');

        this._client = options.client;

        // Initialize core collections and variables
        this._widget = options.widget;

        this._currentNodeId = null;
        this._currentNodeParentId = undefined;

        this._initWidgetEventHandlers();

        this._logger.debug('ctor finished');
    }

    SemanticGraphControl.prototype = Object.create(EasyDAGControl.prototype);

    SemanticGraphControl.prototype.DEFAULT_DECORATOR = 'SemanticNodeDecorator';
    SemanticGraphControl.prototype._initWidgetEventHandlers = function () {
        EasyDAGControl.prototype._initWidgetEventHandlers.call(this);

        this._widget.getAllAuthors = () => {
            // TODO: Get the authors using the client
            const subgraph = this._client.getNode(this._currentNodeId);
        };

        this._widget.getEdgeTypes = () => {
            const metanodes = this._client.getAllMetaNodes();
            const edge = metanodes.find(node => node.getAttribute('name') === 'Edge');

            // TODO: Should we include "Edge"
            return metanodes
                .filter(node => node.isTypeOf(edge.getId()) && node !== edge)
                .map(node => node.getAttribute('name'));
        };

        this._widget.getValidConnectionTypes = (srcId, dstId) => {
            // TODO: Get all valid edges btwn the given nodes
        };

        this._widget.createNode = dict => {
            // TODO
        };

        this._widget.createEdge = dict => {
            // TODO
        };

        this._widget.createNodeType = dict => {
            // TODO
        };

        this._widget.createEdgeType = dict => {
            // TODO: Define a new meta node that inherits from 'Edge' or some specified base
        };
    };

    /* * * * * * * * Visualizer content update callbacks * * * * * * * */
    // One major concept here is with managing the territory. The territory
    // defines the parts of the project that the visualizer is interested in
    // (this allows the browser to then only load those relevant parts).
    SemanticGraphControl.prototype.selectedObjectChanged = function (nodeId) {
        var desc = this._getObjectDescriptor(nodeId),
            self = this;

        self._logger.debug('activeObject nodeId \'' + nodeId + '\'');

        // Remove current territory patterns
        if (self._currentNodeId) {
            self._client.removeUI(self._territoryId);
        }

        self._currentNodeId = nodeId;
        self._currentNodeParentId = undefined;

        if (typeof self._currentNodeId === 'string') {
            // Put new node's info into territory rules
            self._selfPatterns = {};
            self._selfPatterns[nodeId] = {children: 0};  // Territory "rule"

            self._widget.setTitle(desc.name.toUpperCase());

            if (typeof desc.parentId === 'string') {
                self.$btnModelHierarchyUp.show();
            } else {
                self.$btnModelHierarchyUp.hide();
            }

            self._currentNodeParentId = desc.parentId;

            self._territoryId = self._client.addUI(self, function (events) {
                self._eventCallback(events);
            });

            // Update the territory
            self._client.updateTerritory(self._territoryId, self._selfPatterns);

            self._selfPatterns[nodeId] = {children: 1};
            self._client.updateTerritory(self._territoryId, self._selfPatterns);
        }
    };

    // This next function retrieves the relevant node information for the widget
    SemanticGraphControl.prototype._getObjectDescriptor = function (nodeId) {
        const desc = EasyDAGControl.prototype._getObjectDescriptor.call(this, nodeId);
        const node = this._client.getNode(nodeId);

        if (node) {
            const isConnection = node.getPointerNames().includes('src') && 
                node.getPointerNames().includes('dst');

            if (isConnection) {
                desc.srcId = node.getPointerId('src');
                desc.dstId = node.getPointerId('dst');
                desc.types = this.getBaseTypesUntil(node, 'Edge');
            } else {
                desc.types = this.getBaseTypesUntil(node, 'Node');
            }
        }

        return desc;
    };

    SemanticGraphControl.prototype.getBaseTypesUntil = function (node, end='FCO') {
        const types = [];

        while (node && node.getAttribute('name') !== end) {
            node = this._client.getNode(node.getBaseId());
            if (node && node.isMetaNode()) {
                types.push(node.getAttribute('name'));
            }
        }

        return types;
    };

    return SemanticGraphControl;
});
