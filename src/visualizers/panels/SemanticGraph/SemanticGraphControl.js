/*globals define, WebGMEGlobal*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Mon Jul 22 2019 15:40:44 GMT-0700 (PDT).
 */

define([
    'panels/EasyDAG/EasyDAGControl',
    'js/RegistryKeys',
    'js/Constants',
    'js/Panels/MetaEditor/MetaEditorConstants',
], function (
    EasyDAGControl,
    REGISTRY_KEYS,
    CONSTANTS,
    META_CONSTANTS,
) {

    'use strict';

    function SemanticGraphControl(options) {

        this._logger = options.logger.fork('Control');

        this._client = options.client;

        // Initialize core collections and variables
        this._widget = options.widget;

        this._currentNodeId = null;
        this._currentNodeParentId = undefined;

        this._initWidgetEventHandlers();

        this._logger.debug('ctor finished');
    }

    SemanticGraphControl.prototype = Object.create(EasyDAGControl.prototype);

    SemanticGraphControl.prototype.DEFAULT_DECORATOR = 'SemanticNodeDecorator';
    SemanticGraphControl.prototype._initWidgetEventHandlers = function () {
        EasyDAGControl.prototype._initWidgetEventHandlers.call(this);

        this._widget.getAllAuthors = () => {
            // TODO: Get the authors using the client
            const subgraph = this._client.getNode(this._currentNodeId);
        };

        this._widget.getEdgeTypes = () => {
            const metanodes = this._client.getAllMetaNodes();
            const edge = metanodes.find(node => node.getAttribute('name') === 'Edge');

            // TODO: Should we include "Edge"
            return metanodes
                .filter(node => node.isTypeOf(edge.getId()) && node !== edge)
                .map(node => node.getAttribute('name'));
        };

        this._widget.getValidConnectionTypes = (srcId, dstId) => {
            // TODO: Get all valid edges btwn the given nodes
        };

        this._widget.createNode = dict => {
            // TODO
        };

        this._widget.createConnectionType = (name, type) => {
            this.createNew(name, type);
        };

        this._widget.createNodeType = dict => {
            // TODO
        };

        this._widget.getConnectableNodes = (nodeId, reverse) => {
            const nodeIds = this._client.getNode(this._currentNodeId).getChildrenIds()
                .filter(id => id !== nodeId);

            return this.getConnectableNodes(nodeId, nodeIds, reverse);
        };
    };

    SemanticGraphControl.prototype.createNew = function(name, type, metasheetName='META') {
        const client = this._client;
        const baseId = client.getAllMetaNodes()
                .find(node => node.getAttribute('name') === type)
                .getId();

        // Store the new node in the "Language" container
        const parentId = client.getAllMetaNodes()
            .find(node => node.getAttribute('name') === 'Language')
            .getId();

        const msg = `Created new ${type + (metasheetName ? ' prototype' : '')}`;
        client.startTransaction(msg);

        const newId = client.createNode({parentId, baseId});

        // Set isAbstract false, if needed
        const baseNode = client.getNode(baseId);
        if (baseNode.getRegistry('isAbstract')) {
            client.setRegistry(newId, 'isAbstract', false);
        }
        client.setAttribute(newId, 'name', name);

        this.addToMetaSheet(newId, metasheetName);

        client.completeTransaction();

        return newId;
    };

    SemanticGraphControl.prototype.addToMetaSheet = function(nodeId, metasheetName) {
        var root = this._client.getNode(CONSTANTS.PROJECT_ROOT_ID),
            metatabs = root.getRegistry(REGISTRY_KEYS.META_SHEETS),
            metatab = metatabs.find(tab => tab.title === metasheetName) || metatabs[0],
            metatabId = metatab.SetID;

        // Add to the general meta
        this._client.addMember(
            CONSTANTS.PROJECT_ROOT_ID,
            nodeId,
            META_CONSTANTS.META_ASPECT_SET_NAME
        );
        this._client.setMemberRegistry(
            CONSTANTS.PROJECT_ROOT_ID,
            nodeId,
            META_CONSTANTS.META_ASPECT_SET_NAME,
            REGISTRY_KEYS.POSITION,
            {
                x: 100,
                y: 100
            }
        );

        // Add to the specific sheet
        this._client.addMember(CONSTANTS.PROJECT_ROOT_ID, nodeId, metatabId);
        this._client.setMemberRegistry(
            CONSTANTS.PROJECT_ROOT_ID,
            nodeId,
            metatabId,
            REGISTRY_KEYS.POSITION,
            {
                x: 100,
                y: 100
            }
        );
    };

    SemanticGraphControl.prototype.getConnectableNodes = function(src, dsts, reverse) {
        var children = this._getAllValidChildren(this._currentNodeId),
            connIds = [],
            tgts = [],
            validDsts,
            typeId,
            node,
            i;

        for (i = children.length; i--;) {
            node = this._client.getNode(children[i]);
            if (node.isConnection()) {
                // If the conn can start at src, record it
                if (this.connCanStartAt(src, children[i], reverse)) {
                    connIds.push(children[i]);
                }
            }
        }

        // Store the valid target types for each connection
        validDsts = this.getDstToConnIds(connIds);
        for (i = dsts.length; i--;) {
            node = this._client.getNode(dsts[i]);
            typeId = node.getMetaTypeId();
            if (src !== dsts[i] && validDsts[typeId]) {
                tgts.push({
                    node: this._getObjectDescriptor(dsts[i]),
                    conns: validDsts[typeId].map(id => this._getObjectDescriptor(id))
                });
            }
        }

        return tgts;
    };

    SemanticGraphControl.prototype.getDstToConnIds = function(connIds, reverse) {
        var dstDict = {},
            descs,
            items,
            ptr = reverse ? 'src' : 'dst';

        for (var i = connIds.length; i--;) {
            items = this._client.getPointerMeta(connIds[i], ptr).items;
            for (var j = items.length; j--;) {
                // Get all descendents
                descs = this._getAllDescendentIds(items[j].id);
                if (!dstDict[items[j].id]) {
                    dstDict[items[j].id] = [];
                }
                dstDict[items[j].id].push(connIds[i]);

                for (var k = descs.length; k--;) {
                    if (!dstDict[descs[k]]) {
                        dstDict[descs[k]] = [];
                    }
                    dstDict[descs[k]].push(connIds[i]);
                }
            }
        }
        return dstDict;
    };
    /* * * * * * * * Visualizer content update callbacks * * * * * * * */
    // One major concept here is with managing the territory. The territory
    // defines the parts of the project that the visualizer is interested in
    // (this allows the browser to then only load those relevant parts).
    SemanticGraphControl.prototype.selectedObjectChanged = function (nodeId) {
        var desc = this._getObjectDescriptor(nodeId),
            self = this;

        self._logger.debug('activeObject nodeId \'' + nodeId + '\'');

        // Remove current territory patterns
        if (self._currentNodeId) {
            self._client.removeUI(self._territoryId);
        }

        self._currentNodeId = nodeId;
        self._currentNodeParentId = undefined;

        if (typeof self._currentNodeId === 'string') {
            // Put new node's info into territory rules
            self._selfPatterns = {};
            self._selfPatterns[nodeId] = {children: 0};  // Territory "rule"

            self._widget.setTitle(desc.name.toUpperCase());

            if (typeof desc.parentId === 'string') {
                self.$btnModelHierarchyUp.show();
            } else {
                self.$btnModelHierarchyUp.hide();
            }

            self._currentNodeParentId = desc.parentId;

            self._territoryId = self._client.addUI(self, function (events) {
                self._eventCallback(events);
            });

            // Update the territory
            self._client.updateTerritory(self._territoryId, self._selfPatterns);

            self._selfPatterns[nodeId] = {children: 1};
            self._client.updateTerritory(self._territoryId, self._selfPatterns);
        }
    };

    // This next function retrieves the relevant node information for the widget
    SemanticGraphControl.prototype._getObjectDescriptor = function (nodeId) {
        const desc = EasyDAGControl.prototype._getObjectDescriptor.call(this, nodeId);
        const node = this._client.getNode(nodeId);

        if (node) {
            const isConnection = node.getPointerNames().includes('src') && 
                node.getPointerNames().includes('dst');

            if (isConnection) {
                desc.srcId = node.getPointerId('src');
                desc.dstId = node.getPointerId('dst');
                desc.types = this.getBaseTypesUntil(node, 'Edge');
            } else {
                desc.types = this.getBaseTypesUntil(node, 'Node');
            }
        }

        return desc;
    };

    SemanticGraphControl.prototype.getBaseTypesUntil = function (node, end='FCO') {
        const types = [];

        while (node && node.getAttribute('name') !== end) {
            node = this._client.getNode(node.getBaseId());
            if (node && node.isMetaNode()) {
                types.push(node.getAttribute('name'));
            }
        }

        return types;
    };

    return SemanticGraphControl;
});
