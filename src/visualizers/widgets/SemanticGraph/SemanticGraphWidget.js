/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Mon Jul 22 2019 15:40:44 GMT-0700 (PDT).
 */

define([
    'widgets/EasyDAG/EasyDAGWidget',
    './lib/elk.bundled',
    './SelectionManager',
    'underscore',
    'text!./styles/SemanticGraphWidget.css',  // example loading text w/ requirejs
    'css!./styles/SemanticGraphWidget.css'
], function (
    EasyDAGWidget,
    ELK,
    SelectionManager,
    _,
    cssText
) {
    'use strict';

    const elk = new ELK()
    var WIDGET_CLASS = 'semantic-graph';

    function SemanticGraphWidget(logger, container) {
        EasyDAGWidget.apply(this, arguments);
    }

    SemanticGraphWidget.prototype = Object.create(EasyDAGWidget.prototype);

    SemanticGraphWidget.prototype.SelectionManager = SelectionManager;

    SemanticGraphWidget.prototype.startConnectionFrom = function (item) {
        const validPairs = this.getConnectableNodes(item.id);
        this.startConnection(item, validPairs);
    };

    SemanticGraphWidget.prototype.startConnectionTo = function (item) {
        const validPairs = this.getConnectableNodes(item.id);
        this.startConnection(item, validPairs, true);
    };

    SemanticGraphWidget.prototype.startConnection = function (src, dsts, reverse) {
        var onClick = (clicked, conns) => {
                var srcId = !reverse ? src.id : clicked.id,
                    dstId = !reverse ? clicked.id : src.id;

                d3.event.stopPropagation();
                this.resetConnectingState();

                if (conns.length > 1) {
                    // TODO: Prompt the user for the edge type!
                    // After we have determined the actual connection to create,
                    // call:
                    //
                    //     this.connectNodes(srcId, dstId, connId);
                    //
                    // New connection type can be created with:
                    //
                    //     this.createConnectionType(name, baseName);
                    //
                    console.log(`Found ${conns.length} valid connections.`);
                    console.log(conns.map(c => c.name));
                    // The following fn will get all connection types (including their base type)
                    console.log(this.getAllConnectionTypes());
                } else {
                    this.connectNodes(srcId, dstId, conns[0].id);
                }
            },
            pairs = dsts.map(pair => [this.items[pair.node.id], pair.conns]);

        this.resetConnectingState();
        this._connectionSrc = src;
        const tuples = pairs.map(pair => {
            var item = pair[0],
                connIds = pair[1];

            return [
                item,
                connIds,
                item.showIcon({
                    x: 0.5,
                    y: !reverse ? 0 : 1,
                    icon: 'chevron-bottom'
                })
            ];
        });

        tuples.forEach(pair => pair[2].on('click', () => onClick(pair[0], pair[1])));

        // Create the 'create-new' icon for the src
        const srcIcon = src.showIcon({
            x: 0.5,
            y: !reverse ? 1 : 0,
            icon: 'plus'
        });
        srcIcon.on('click', () => {
            d3.event.stopPropagation();
            this.resetConnectingState();
            this.onAddButtonClicked(src, reverse);
        });

        this._connectionOptions = tuples.map(tuple => [tuple[0], tuple[2]]);
        this._connectionSrc = [src, srcIcon];

        this._connecting = true;
    };

    SemanticGraphWidget.prototype.refreshScreen = function () {
        if (!this.active) {
            return;
        }

        // WRITE UPDATES
        // Update the locations of all the nodes

        const nodes = Object.values(this.items)
            .map(item => _.pick(item, ['id', 'width', 'height']));
        const edges = Object.values(this.connections)
            .map(conn => ({id: conn.id, sources: [conn.src], targets: [conn.dst]}));

        const graph = {
            id: "root",
            layoutOptions: {
                'elk.algorithm': 'mrtree',
                'elk.spacing.nodeNode': 50,
            },
            children: nodes,
            edges: edges
        };

        return elk.layout(graph)
            .then(graph => {
                this.queueFns([
                    this.updateTranslation.bind(this),
                    this.refreshItems.bind(this, graph),
                    this.refreshConnections.bind(this, graph),
                    this.selectionManager.redraw.bind(this.selectionManager),
                    this.updateContainerWidth.bind(this),
                    this.refreshExtras.bind(this)
                ]);
            });
    };

    SemanticGraphWidget.prototype.refreshExtras = function () {
        this.updateEmptyMsg();
    };

    SemanticGraphWidget.prototype.refreshConnections = function (graph) {
        const connIds = Object.keys(this.connections);
        this._logger.debug(`Refreshing ${connIds.length} connections`);

        for (let i = graph.edges.length; i--;) {
            const id = graph.edges[i].id;
            if (!graph.edges[i].sections && graph.edges[i].sources[0] === graph.edges[i].targets[0]) {
                console.warn(`Unable to render edge ${id}. Self-connections not supported by current layout.`);
                continue;
            }

            this.connections[id].points = graph.edges[i].sections
                .map(sec => sec.endPoint);

            this.connections[id].points.unshift(graph.edges[i].sections[0].startPoint);
            this.connections[id].redraw();
        }
    };

    SemanticGraphWidget.prototype.refreshItems = function (graph) {
        this._logger.info(`Redrawing ${graph.children.length} nodes`);
        for (let i = graph.children.length; i--;) {
            const id = graph.children[i].id;
            const item = this.items[id];
            item.x = graph.children[i].x + item.width/2;
            item.y = graph.children[i].y + item.height/2;
            item.redraw(this._zoomValue);
        }
    };

    return SemanticGraphWidget;
});
