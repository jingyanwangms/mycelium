/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Mon Jul 22 2019 15:40:44 GMT-0700 (PDT).
 */

define([
    'widgets/EasyDAG/EasyDAGWidget',
    './lib/elk.bundled',
    './SelectionManager',
    'underscore',
    'text!./styles/SemanticGraphWidget.css',  // example loading text w/ requirejs
    'css!./styles/SemanticGraphWidget.css'
], function (
    EasyDAGWidget,
    ELK,
    SelectionManager,
    _,
    cssText
) {
    'use strict';

    const elk = new ELK()
    var WIDGET_CLASS = 'semantic-graph';

    function SemanticGraphWidget(logger, container) {
        EasyDAGWidget.apply(this, arguments);
    }

    SemanticGraphWidget.prototype = Object.create(EasyDAGWidget.prototype);

    SemanticGraphWidget.prototype.SelectionManager = SelectionManager;
    SemanticGraphWidget.prototype.refreshScreen = function () {
        if (!this.active) {
            return;
        }

        // WRITE UPDATES
        // Update the locations of all the nodes

        const nodes = Object.values(this.items)
            .map(item => _.pick(item, ['id', 'width', 'height']));
        const edges = Object.values(this.connections)
            .map(conn => ({id: conn.id, sources: [conn.src], targets: [conn.dst]}));

        const graph = {
            id: "root",
            layoutOptions: {
                'elk.algorithm': 'mrtree',
                'elk.spacing.nodeNode': 50,
            },
            children: nodes,
            edges: edges
        };

        return elk.layout(graph)
            .then(graph => {
                this.queueFns([
                    this.updateTranslation.bind(this),
                    this.refreshItems.bind(this, graph),
                    this.refreshConnections.bind(this, graph),
                    this.selectionManager.redraw.bind(this.selectionManager),
                    this.updateContainerWidth.bind(this),
                    this.refreshExtras.bind(this)
                ]);
            });
    };

    SemanticGraphWidget.prototype.refreshConnections = function (graph) {
        const connIds = Object.keys(this.connections);
        this._logger.debug(`Refreshing ${connIds.length} connections`);

        for (let i = graph.edges.length; i--;) {
            const id = graph.edges[i].id;
            if (!graph.edges[i].sections && graph.edges[i].sources[0] === graph.edges[i].targets[0]) {
                console.warn(`Unable to render edge ${id}. Self-connections not supported by current layout.`);
                continue;
            }

            this.connections[id].points = graph.edges[i].sections
                .map(sec => sec.endPoint);

            this.connections[id].points.unshift(graph.edges[i].sections[0].startPoint);
            this.connections[id].redraw();
        }
    };

    SemanticGraphWidget.prototype.refreshItems = function (graph) {
        this._logger.info(`Redrawing ${graph.children.length} nodes`);
        for (let i = graph.children.length; i--;) {
            const id = graph.children[i].id;
            const item = this.items[id];
            item.x = graph.children[i].x + item.width/2;
            item.y = graph.children[i].y + item.height/2;
            item.redraw(this._zoomValue);
        }
    };

    return SemanticGraphWidget;
});
